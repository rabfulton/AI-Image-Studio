#!/usr/bin/env python3
"""
Update the in-app model catalog from stable-diffusion.cpp docs.

Source:
  https://github.com/leejet/stable-diffusion.cpp

This script fetches selected markdown files from the upstream repo and extracts
Hugging Face links of the form:
  https://huggingface.co/<repo>/resolve/main/<filename>
  https://huggingface.co/<repo>/blob/main/<filename>

It then rewrites the AUTOGENERATED section in:
  src/ai_image_studio/ui/dialogs/model_catalog.py

Notes:
- Network access required.
- The output is intentionally conservative: it focuses on models that should be
  usable with stable-diffusion.cpp without additional conversion steps.
"""

from __future__ import annotations

import re
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable
from urllib.request import urlopen, Request


UPSTREAM_BASE = "https://raw.githubusercontent.com/leejet/stable-diffusion.cpp/master"
SOURCES = [
    "README.md",
    "docs/sd.md",
    "docs/distilled_sd.md",
]


@dataclass(frozen=True)
class ResolvedFile:
    repo: str
    filename: str


HF_RESOLVE_RE = re.compile(
    r"https?://huggingface\.co/(?P<repo>[^/\s]+/[^/\s]+)/(?P<kind>resolve|blob)/main/(?P<file>[^\s)]+)",
    re.IGNORECASE,
)

HF_REPO_RE = re.compile(
    r"https?://huggingface\.co/(?P<repo>[^/\s]+/[^/\s]+)(?:\s|$|/|\))",
    re.IGNORECASE,
)


def fetch_text(url: str) -> str:
    req = Request(url, headers={"User-Agent": "ai-image-studio/0.1 model catalog updater"})
    with urlopen(req, timeout=30) as resp:
        return resp.read().decode("utf-8", errors="replace")


def extract_resolved_files(text: str) -> list[ResolvedFile]:
    items: list[ResolvedFile] = []
    for m in HF_RESOLVE_RE.finditer(text):
        repo = m.group("repo")
        filename = m.group("file")
        # Strip trailing punctuation that can appear in markdown.
        filename = filename.rstrip(").,]\"'")
        items.append(ResolvedFile(repo=repo, filename=filename))
    # De-duplicate stable order
    seen: set[tuple[str, str]] = set()
    out: list[ResolvedFile] = []
    for it in items:
        key = (it.repo, it.filename)
        if key in seen:
            continue
        seen.add(key)
        out.append(it)
    return out


def extract_repo_links(text: str) -> list[str]:
    repos: list[str] = []
    for m in HF_REPO_RE.finditer(text):
        repo = m.group("repo").rstrip(").,]\"'")
        # Drop obvious non-model repos we don't want to offer as downloadable "models"
        if repo.lower().endswith("/tree") or repo.lower().endswith("/blob"):
            continue
        repos.append(repo)
    # De-duplicate
    seen: set[str] = set()
    out: list[str] = []
    for r in repos:
        if r in seen:
            continue
        seen.add(r)
        out.append(r)
    return out


def render_catalog() -> str:
    """
    Generate a conservative catalog based on extracted links plus a few
    stable-diffusion.cpp-referenced repos.
    """
    resolved: list[ResolvedFile] = []
    repo_links: list[str] = []

    for rel in SOURCES:
        url = f"{UPSTREAM_BASE}/{rel}"
        text = fetch_text(url)
        resolved.extend(extract_resolved_files(text))
        repo_links.extend(extract_repo_links(text))

    resolved_map = {(r.repo, r.filename) for r in resolved}

    def has(repo: str, filename: str) -> bool:
        return (repo, filename) in resolved_map

    # Build a small "nice selection" focusing on common SD models.
    entries: list[str] = []

    # SD 1.5 safetensors (explicitly referenced in README)
    # The upstream docs reference `runwayml/stable-diffusion-v1-5`, but that repo is often gated.
    # Use an ungated mirror that includes the same safetensors for one-click downloads.
    entries.append(
        """CatalogModel(
        name="Stable Diffusion 1.5 (safetensors)",
        description="Baseline SD 1.5 model (single file, ungated mirror for easy download)",
        architecture="sd15",
        artifacts=[
            ModelArtifact(repo="second-state/stable-diffusion-v1-5-GGUF", filename="v1-5-pruned-emaonly.safetensors")
        ],
        include_components=False,
    ),"""
    )

    # SDXL base (+ VAE fix) referenced in docs/sd.md via example invocation
    if has("stabilityai/stable-diffusion-xl-base-1.0", "sd_xl_base_1.0.safetensors") and has(
        "madebyollin/sdxl-vae-fp16-fix", "sdxl_vae-fp16-fix.safetensors"
    ):
        entries.append(
            """CatalogModel(
        name="Stable Diffusion XL Base 1.0 (+ VAE fix)",
        description="SDXL base model plus recommended VAE fix from stable-diffusion.cpp docs",
        architecture="sdxl",
        artifacts=[
            ModelArtifact(repo="stabilityai/stable-diffusion-xl-base-1.0", filename="sd_xl_base_1.0.safetensors"),
            ModelArtifact(
                repo="madebyollin/sdxl-vae-fp16-fix",
                filename="sdxl_vae-fp16-fix.safetensors",
                description="VAE fix (pass as --vae / vae_path)",
            ),
        ],
        include_components=False,
    ),"""
        )

    # SSD-1B out-of-the-box (distilled models doc)
    if has("segmind/SSD-1B", "SSD-1B-A1111.safetensors"):
        entries.append(
            """CatalogModel(
        name="SSD-1B (SDXL distilled, A1111 safetensors)",
        description="Smaller distilled SDXL-style model from stable-diffusion.cpp docs (out-of-the-box)",
        architecture="sdxl",
        artifacts=[ModelArtifact(repo="segmind/SSD-1B", filename="SSD-1B-A1111.safetensors")],
        include_components=False,
    ),"""
        )

    if has("hassenhamdi/SSD-1B-fp8_e4m3fn", "SSD-1B_fp8_e4m3fn.safetensors"):
        entries.append(
            """CatalogModel(
        name="SSD-1B (fp8 safetensors)",
        description="SSD-1B fp8 variant (may require newer GPUs/drivers; out-of-the-box per docs)",
        architecture="sdxl",
        artifacts=[ModelArtifact(repo="hassenhamdi/SSD-1B-fp8_e4m3fn", filename="SSD-1B_fp8_e4m3fn.safetensors")],
        include_components=False,
    ),"""
        )

    # Turbo repos are referenced in stable-diffusion.cpp README as supported models.
    # Add them as "auto-select" entries.
    for repo, name, arch in [
        ("stabilityai/sd-turbo", "SD Turbo (auto-select)", "sd-turbo"),
        ("stabilityai/sdxl-turbo", "SDXL Turbo (auto-select)", "sdxl-turbo"),
    ]:
        if repo in repo_links:
            entries.append(
                f"""CatalogModel(
        name="{name}",
        description="Downloads a matching safetensors file from the repo",
        architecture="{arch}",
        artifacts=[ModelArtifact(repo="{repo}", patterns=["*.safetensors"])],
        include_components=False,
    ),"""
            )

    # Keep existing GGUF SD 1.5 Q4_0 entry (works well for low VRAM), even if not referenced upstream.
    entries.insert(
        1,
        """CatalogModel(
        name="Stable Diffusion 1.5 (GGUF Q4_0)",
        description="Quantized SD 1.5 GGUF (smallest). Downloads companion components if available in repo.",
        architecture="sd15",
        artifacts=[
            ModelArtifact(
                repo="second-state/stable-diffusion-v1-5-GGUF",
                filename="stable-diffusion-v1-5-pruned-emaonly-Q4_0.gguf",
            )
        ],
        include_components=True,
    ),""",
    )

    body = "MODEL_CATALOG: list[CatalogModel] = [\n" + "\n".join(f"    {e}\n" for e in entries) + "]\n"
    return body


def replace_autogen_section(path: Path, new_body: str) -> None:
    text = path.read_text(encoding="utf-8")
    start = "# BEGIN AUTOGENERATED"
    end = "# END AUTOGENERATED"

    if start not in text or end not in text:
        raise RuntimeError(f"Missing AUTOGENERATED markers in {path}")

    before, rest = text.split(start, 1)
    _, after = rest.split(end, 1)

    updated = before + start + " (do not edit by hand)\n" + new_body + end + after
    path.write_text(updated, encoding="utf-8")


def main(argv: list[str]) -> int:
    target = Path("src/ai_image_studio/ui/dialogs/model_catalog.py")
    if not target.exists():
        print(f"Missing target file: {target}", file=sys.stderr)
        return 2

    try:
        body = render_catalog()
    except Exception as e:
        print(f"Failed to fetch/parse upstream docs: {e}", file=sys.stderr)
        return 1

    replace_autogen_section(target, body)
    print(f"Updated catalog: {target}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
